package proyectocompi;

import java_cup.runtime.*;
import java.io.FileInputStream;
import java.io.InputStream;
import javax.swing.JTextArea;

parser code
{:
    
    public JTextArea outputArea;
    public  int errors = 0;
    
    @Override
    public void syntax_error(Symbol s){
        report_error("Syntax Error: Unexpected Token "+s.value+" at Line "+(s.left+1)+" Column "+(s.right+1), "" );
    }

    @Override
    public void report_error(String message, Object info) {
    if (info instanceof String){
	errors++; 
        outputArea.append("("+errors+")> " + message + info + "\n");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }
   
  @Override
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }

    public void setOutput(JTextArea out){
        this.outputArea = out;
    }

:}


//TERMINALES

// Tipos
terminal NUM, BIN, DEC, SYM, STR;

// Valores Con sus Java Types
terminal java.lang.Boolean BOOL;
terminal java.lang.Number DIGIT;
terminal java.lang.Number FLOAT;
terminal java.lang.Character CHAR;
terminal java.lang.String STRING;
terminal java.lang.String ID;
//terminal BOOL, DIGIT,CHAR, STRING, FLOAT;

// Statements
terminal END, ASSIGN;


// Ciclo FOR
terminal REP, REPEND, OUT;

// IF
terminal COND, CONDEND, YET, YETEND;


// SWITCH 
terminal SET, SETEND, OPT, ANY;//THEN;


// WHILE
terminal TIL, TILEND;

// Main & Funciones
terminal MAIN, MAINEND, ACT, ACTEND, RET;//NIL;

// Operadores 
terminal PLUS, MINUS, MULT, DIV, MOD;//, DOT;

// Operadores Logicos
terminal AND, OR, LESSTHAN, GREATERTHAN, GREATEREQUALTHAN, LESSEQUALTHAN, EQUAL, NOTEQUAL, NOT;

// Fillers
terminal PARIZQ, PARDER, COMMA;//, BRAIZQ, BRADER, INCLUDE;

//NO TEMRINALES
non terminal PROGRAM, PROGRAM_BODY;

non terminal IF_S, IF_A, IF_B, IF_C, FOR_S, FOR_A, FOR_B, WHILE_S, WHILE_A, SWITCH_S, SWITCH_A, SWITCH_B, SWITCH_C, SWITCH_D, SWITCH_TYPES, DECLARE_END, FUNC_S, FUNC_A, FUNC_B;


//Sept No Terminales
non terminal DECLARE_S, DECLARE_A, DECLARE_B, DECLARE_FOR, TYPES, LITERALS, E, T, F;
non terminal LogicalOperators, Concat, Negation, LogicalA, LogicalB;
non terminal ELogical, TLogical, FLogical;

non terminal WHILE_B, STATEMENT, STATEMENTS;

start with PROGRAM;

TYPES ::= NUM | DEC | BIN | SYM | STR | ;
LITERALS ::= BOOL | DIGIT | FLOAT | CHAR | STRING | ID;

//DECLARACION
DECLARE_END ::= END;
DECLARE_B ::= ID COMMA DECLARE_B 
        | ID DECLARE_END;
DECLARE_A ::= ID ASSIGN E DECLARE_END;
DECLARE_S ::= TYPES DECLARE_A 
        | TYPES DECLARE_B;
//DECLARACION END

//DECLARACION PARA EL FOR
DECLARE_FOR ::= TYPES ID ASSIGN E;
//CASO ESPECIAL

//ARIT OPERATION
F ::= LITERALS 
    | PARIZQ E PARDER;
T ::= T MULT F 
    | T DIV F 
    | T MOD F 
    | F;
E ::= E PLUS T 
    | E MINUS T 
    | T;
//ARIT ::= E END;
//ARIT OPERATION END



Concat ::= AND | OR;
Negation ::= NOT | ;
LogicalOperators ::= LESSTHAN | GREATERTHAN | LESSEQUALTHAN | GREATEREQUALTHAN | EQUAL | NOTEQUAL;


//Logical Operations
LogicalB ::= ELogical LogicalOperators LogicalB 
            | ELogical;
LogicalA ::= LogicalA Concat LogicalB 
            | LogicalB;

//Arithmetic Operations for Logical Statements.
FLogical ::= Negation LITERALS
        | Negation PARIZQ LogicalA PARDER;
TLogical ::= TLogical MULT FLogical 
        | TLogical DIV FLogical 
        | TLogical MOD FLogical 
        | FLogical;
ELogical ::= ELogical PLUS TLogical 
        | ELogical MINUS TLogical 
        | TLogical;

//FUNCTION
FUNC_S ::= ACT ID PARIZQ PARDER PROGRAM_BODY FUNC_A ACTEND;
FUNC_A ::= RET LITERALS END | ; 
//FUNCTION END

//IF 
IF_C ::= PROGRAM_BODY CONDEND YET PROGRAM_BODY YETEND 
    | PROGRAM_BODY CONDEND;
IF_S ::= COND PARIZQ LogicalA PARDER IF_C;
// IF END

//FOR 
FOR_B ::= PROGRAM_BODY REPEND | PROGRAM_BODY OUT END REPEND;
FOR_A ::= PARIZQ DECLARE_S LogicalA END DECLARE_FOR PARDER FOR_B;
FOR_S ::= REP FOR_A; 
//FOR END

//WHILE
    WHILE_A ::= TILEND | OUT END TILEND;
    WHILE_S ::= TIL PARIZQ LogicalA PARDER PROGRAM_BODY WHILE_A ;
//WHILE END

//SWITCH 
    SWITCH_TYPES ::= CHAR | DIGIT | ID;
    SWITCH_D ::= OUT END | ;
    SWITCH_C ::= SWITCH_C OPT PARIZQ SWITCH_TYPES PARDER PROGRAM_BODY SWITCH_D ;
    SWITCH_B ::= SWITCH_C ANY PROGRAM_BODY SWITCH_D SWITCH_C 
        | SWITCH_C;
    SWITCH_S ::= SET PARIZQ SWITCH_TYPES PARDER SWITCH_B SETEND;
//SWITCH END

STATEMENTS ::= STATEMENTS STATEMENT
            | STATEMENT
            | error {: parser.report_error("Error in a Statement", ""); :}; 

STATEMENT ::= DECLARE_S
            | IF_S
            | FOR_S
            | WHILE_S 
            | SWITCH_S
            | FUNC_S;

PROGRAM_BODY ::= STATEMENTS | ;

PROGRAM ::= MAIN PROGRAM_BODY MAINEND
        | error PROGRAM_BODY MAINEND {: parser.report_error("RUN END without RUN", ""); :}
        | MAIN error {: parser.report_error("Error Reaching RUN END", ""); :};